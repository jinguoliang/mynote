Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2016-10-12T11:28:11+08:00

====== Effective Java 第二版 ======
Created 星期三 12 十月 2016

==== 第一张 引言 ====

==== 第二章 创建和销毁对象 ====

1. 考虑用静态工厂方法代替构造函数
	a. 与构造器不同，它有名称，产生的客户端代码更易阅读，如果参数列别相同时，构造器是无法区分的
	b. 不必每次调用都创建一个新对象
	c. 可以返回原返回类型的子类对象，具有更大的灵活性，适用于基于接口的框架，外界只需要知道接口，但是可能有各种实现都被隐藏了
	d. 创建参数化实例时，代码更简洁，如 Map<String, List<String>> m = new HashMap<String, List<String>>(); 可以这样  Map<String, List<String>> m = HashMap.newInstance(). 不过java1.7版本可以这么写 Map<String, List<String>> m = new HashMap<>();  这叫类型推导
	e. 缺点， 类如果不含共有或受保护的构造器，则不能子类化。但也可能因祸得福，程序员可以用组合代替继承，而组合很多情况下更好的
	f. 缺点，静态工厂方法与其他静态方法没有区别，没有特别对待，这样就不容易被发现如何实例化一个类，但是可以遵循标准命名来弥补
		1. valueOf 类型转换  of
		2. getInstance， newInstance
		3. getType
		4. newType
2. 遇到多个构造器参数时要考虑用构建器
	a. 重叠构造器模式可行，但是参数很多时，客户端很难编写，顺序，个参数意义呀。。。
	b. JavaBeans 模式，就是无参构造，然后用各种 setXXX（）缺点：__构造过程被分开，JavaBean 可能处于不一致的状态；就不能创建不可变的类__
	c. 构造器模式，
3. 用私有构造器或者枚举类型强化 Singleton 属性 讲了三种方法：
	a. 第一二中相似，只是接口不同，都是定义静态 final 的成员指向自己，__但是序列化时如果只是继承 Serializable 是不够的，必须声明所有实例域是瞬时的（transient）并提供一个 readResolve（见77），否则每次反序列化一个序列化实例时，都会创建一个实例__
		1. 第一种，直接暴露成员 INSTANCE
		2. 第二种，使用工厂方法，更灵活，更易修改，可以控制实例的数量，或者每个线程独有的实例数量
		3. 构造函数私有化，同时内部抛出异常，防止外部通过反射调用
	b. 使用枚举，只有一个元素，自动提供序列化机制
4. 通过私有构造器强化不可实例化的能力
	a. 对于只含有静态方法和静态属性的类，为避免实例化，声明构造函数为私有，并在里面抛出异常，避免内部吴用
	b. 这样副作用是不能被继承了，因为构造函数必须被子类显示或隐式调用
5. 避免创建不必要的对象
	a. String s = "stringette";  同一虚拟机中的所有使用该字面常量的引用都指向一个对象
	b. 同时提供静态工厂方法和构造器的不可变类，优先选择静态工厂方法，如 Boolean.valueOf（String） ， Boolean（String）
	c. 某些属性是不变的，整个类都不变的，所以静态初始化
	d. 某些adapter，它们只负责将中间委托功能，转换接口，所以也可以重用
	e. 注意自动装箱，避免产生大量对象
	f. 创建小对象是很快的，所以创建对象池要慎重，真的是那些占用内存大的对象，如线程对象，数据库链接对象
	g. 对应的 __39条，保护性拷贝，__必要时没有拷贝，讲导致错误，而不必要的创建对象会影响程序风格
6. 消除过期的对象引用
	a. 首先要知道：内存泄露什么意思？ 是动态分配的内存在使用完后，没有被释放
	b. java 中，在使用完后，生命期结束了，要置为 null， 这样做的另一个好处是被错误引用时会立即报异常
	c. 内存泄露的来源
		1. 类自己管理内存如 ArrayList
		2. 缓存， 如何解决？ 
			a. 使用WeakHashMap 代表缓存， 记住：__只有当缓存项的生命周期是由该键外部引用而不是由值决定时WeakHashMap才有用__
			b. 缓存生命周期不容易确定，是随着时间推移，变得越来越没意义，在这种情况下，要么开个后台线程清除，要么在每次添加心跳木时清理
			c. 更复杂时，使用 java。lang。ref
		3. 监听器或其他回调，注册了却没有取消，这时候最佳方法是保存他们的弱引用
7. 避免使用终结方法
	a. finalize 的执行时间是不确定的，甚至都不一定执行
	b. 不同 jvm 的实现不同，表现也不同
	c. System.gc System.runFinalization也不能保证 finalize 执行
	d. System.runFinalizersOnExit Runtime.runFinalizersOnExit 能保证但存在致命缺陷被废弃了
	e. 如果异常发生在 finalize 方法中，则线程见不会终止，也不打印警告
	f. 自己提供显示的终止方法，并告诉客户端需要调用它，当释放后要标识它不在有效，以免错误调用
	g. 显示的释放如 close， release， cancel， 他们通常与 try-finally 结构结合
	h. 那 finalize 方法有什么意义？
		1. 充当安全网，当忘记调用终结方法时使用，FileInputStream，Connection 都实现了 finalize 方法
		2. 释放native peer 相关的内存，但是如果本地对等体拥有必须及时终止的资源，还是用显示终止方法吧
	i. 终结方法链不是自动的，所以子类在覆盖父类是要显示调用父类的终结方法，并且通过 try-finally
	j. 为了确保父类做终结工作，可以加一个匿名内部类来做，从而避免上一条，因为忘记调用父类的终结方法而没有终结

==== 第三章 对于所有对象都通用的方法 ====

1. 覆盖 equals 时请遵循通用约定
2. 覆盖 equals 时总要覆盖 hashCode
3. 始终要覆盖 toString
4. 谨慎的覆盖 clone
5. 考虑实现 Comparable 接口
