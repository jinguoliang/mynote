Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2015-02-02T10:56:18+08:00

====== 重构--改善既有代码的设计 ======
Created 星期一 02 二月 2015

重构最基本定义：重构是在不改变既有代码的客观查行为的前提下改善其内部结构

设计模式给我们的，不仅仅是一些具体问题的解决方案，更有追求完美“理型"的渴望
单凭对完美的追求无法写出实用的代码，而实用是软件压倒一切的要素
后结构主义者
重构的每个步骤都很简单，甚至过于简单：你只需要把某个字段从一个类移到另一个类，把某些代码从一个函数拉到另一个函数，或是拿出作为一个新函数，或是
在集成体系重把某些代码拉上拉下就行了。但是聚沙成塔，这些小小的积累就可以根本改善设计质量。

==== 1.重构，第一个案例 ====
1.如果你想添加一个新特性，但却很难添加，那就先重构代码吧
2.重构之前程序必须有自我检查能力，测试程序
3.重构技术就是以微笑的步伐修改程序，如果犯下错误，很容易便可发现
4.任何一个傻瓜都能写出计算机理解的程序，唯有写出人类容易理解的代码，才是优秀的程序员

==== 2.重构原则 ====
重构的目的是使软件更容易理解和修改
与性能优化相比，性能优化往往使代码较难理解
__两顶帽子：__
	使用重构技术开发软件时，你把自己的时间分成两部分，添加特性以及重构
	添加功能时，你不应该修改既有代码，添加测试，通过测试，并一次衡量工作进度
	重构时，就不能添加功能，不添加测试，只在绝对必要时才修改测试
	很帽子的步调是这样的：你要开始添加一个功能，但是意识到如果修改一下结构，会更容易添加功能，所以，换上重构帽子，做重构，完成后，你有换上原来的帽子继续添加功能
__为何重构__
	1. 重构改进软件设计
		a. 在完全理解整体设计之前，就贸然修改代码，程序会失去自己的结构，会愈来愈难读。
		b. 重构很像整理代码，你所做的就是让所有东西回到相应的位置
		c. 消除重复 
	2. 重构使软件更容易理解
		a. 当我看一段代码时，我就对自己说：它做了什么，然后真正动手修改，让代码反应我的理解 
	3. 重构帮助找到bug
		a. 对代码的理解，可以帮助找到bug
	4. 重构提高编程速度
__何时重构__
	不应该专门拨出时间来做重构，之所以做重构，是因为你想做别的什么事，而重构可以帮你把事情做好
	应该随时随地进行，目的驱动
	1. //三次法则 	//事不过三，三次重构
	2. 添加功能时重构
		a. 帮我理解代码
		b. 更容易添加功能，不因为过去差的设计而懊恼，用重构来弥补
	3. 修补错误时重构
	4. 复审代码时重构
__计算机科学是这么一门科学：它相信所有问题都可以通过增加一个间接层来解决。__
重构为软件引入更多的间接层。重构往往把大型对象拆成多个小对象，把大型方法函数拆分成多个小函数

=== 重构的难题 ===
1. 数据库　	没感触
2. 修改接口
	a. 如果某个方法的所有使用者都在控制之下，那问题不大，ｅｃｌｉｐｓｅ都有这功能,问题是那些可能存在其他项目里,可能存在文件里
	b. 对于已发布的接口,要保持新旧接口同时存在至少一段时间,但是可以用新接口实现老接口并注释老接口deprecated
	c. 尽量晚发布接口
	d. 有时可能知识添加一个异常声明,此时最好修改接口名称,用b的方法实现,如果是受控异常,需要暂时改为非受控异常,并警告用户,以后会变成受控异常
__不要过早发布接口,请修改你的代码所有权政策,过度强调所有权的团队可能会犯错,最好结对编程来修改某块代码__
重构与设计
一种是预先设计方方面面
一种是不设计,直接随心搞,然后重构
还有一种取中,不必太费尽心思设计一个非常正确的方案,而是较优的,然后就开始实现,同时重构

==== 代码的坏味道 ====
1. 重复代码
2. 过长函数
	a. 名字要能表达意思，要这样，关键是函数要功能单一，简单
3. 过大的类
4. 过长参数列表
5. 发散式变化
6. 霰弹式修改
7. 依恋情节
8. 数据泥团
9. 基本类型偏执
10. switch惊悚现身
11. 平行集成体系
12. 戎赘类
13. 夸夸其谈未来性
	a. 多余的代码就删掉吧，别想未来会用到
14. 令人迷惑的暂时字段（temp）
15. 过度耦合的消息链
16. 中间人
17. 狎昵关系 (Inappropriate Intimacy)
18. 异曲同工的类
19. 不完整的库类
20. 纯挚的数据类
	a. 那些只有字段的类，给他们添加getter和setter然后如果不想被设置去掉setter，然后查看那些用到这些方法的方法，看能不能移到这个类里
21. 被拒绝的遗赠
	a. 子类继承的方法可能永不到，不去实现
22. 过多的注释
	a. 并不是反对注释，而是过多的注释往往表示代码写的很差
__当你感觉需要撰写代码时，首先尝试重构，让注释显得多余__

==== 构筑测试体系 ====
__确保所有测试都自动运行，让他们自己检查运行结果__
__一套测试就是一个强大的bug侦测器，能够大大缩减查找bug的时间__
__频繁运行测试,每次编译,请把测试考虑进去,每天至少执行测试一次__
__每当你收到bug报告,请先写一个单元测试来暴漏bug__
__观察类该做的所有事情,然后针对任何一项功能的任何移植一种失败情况,进行测试,测试应该是风险驱动的行为__
__编写未臻完善的测试并实际运行,好过对完美测试的无尽等待__
__考虑可能出错的边界条件,把火力集中在那儿__
__当事情被认为应该出错时,别忘了检查是否抛出了预期的异常__
__不要因为测试无法捕捉到bug就不写,以为测试的确可以捕捉到大多数bug__

==== 重构列表 ====
重构记录格式：
	名称		
	概要	解决的问题，应该做的事，对比图
	动机										
	做法											
	范例


==== 重新组织函数 ====
1. 提炼函数
	a. 函数的长度不是问题，关键是函数名称和函数本体之间的语义距离
	b. 函数起名，根据它组什么，而不是根据怎么做
2. 内敛函数
	a. 一个函数的本体与名称一样清晰
	b. 内敛是为了重新提炼函数
3. 内敛临时变量
	a. 改为final编译，保证只被赋值过一次
4. 用函数查询替换局部变量
	a. 往往是提炼函数前的不可或缺的步骤
5. 引入解释性变量
	a. 表达式可能非常复杂难懂，这时，临时变量可以帮助分解表达式，使其容易理解
6. 分解临时变量
	a. 一个临时变量只赋值一次
7. 移除对参数的赋值
	a. 对参数赋值会迷魂读者，尤其是在函数很长的时候
8. 以函数对象取代函数
	a. 大的函数，可能不能分解，因为有好多的临时变量，但是放进单独类里，让临时变量成为它的字段，就可以分解他了？
9. 替换算法
	a. 切换不同的实现，前提是先分解的足够小了

==== 在对象之间搬移特性 ====
1. 搬移方法
2. 搬移字段
3. 提炼出新类
4. 将类内敛
5. 隐藏委托关系
	a. 减少耦合
6. 移除中间人
	a. 与5相反，如果一个类通过中间人访问另一个类的太多的方法，那说明他和那个类的关系很紧密，就应该公开它们的关系，不需要中间人介入
7. 引入外加函数
	a. 使用了一个库，但是发现缺少某个功能，此时不能修改那个库，于是我们可以自己写一个方法，传入那个类的对象，该方法应该不引用客户端的属性，并注释因该属于那个库
8. 引入本地扩展
	a. 通7，但是我们要添加更多的功能，我们可以新建各类，来包装或者集成那个类

==== 重新组织数据 ====
1. 自封装字段
	a. 添加getter和setter，当有子类实现时or多态时，功能就体现出来了
2. 以对象取代数据值
	a. 值对象和引用对象相对，值对象时在另一个对象中每次都创建一个，而引用时每次都传进去一个，当然这都是相对的
3. 将值对象改为引用对象
	a. 2中我的理解有点简单，太相对
	b. 作者的解释是：引用对象是像客户，账户这样的东西，每个对象都代表真实世界中的一个实物，你可以直接以相等号来检查对象相等，而值对象（__重要特性：不可变__）是像日期，钱这样的东西，它们完全由其值来定义，你并不在意副本的存在，你通过覆写equal和hashCode来判断相等。
4. 将引用对象改为值对象
	a. 关键根据是否可变，如果不可变，就把它变成值对象
5. 以对象取代数组
	a. 强调一下，小步改动
6. __重复的“被监视数据”__
	a. gui ， mvc分层，这时候，view 和 业务层可能对相同的数据都定义变脸，这就是重复的数据，关键是同步
7. 将单向关联改为双向关联
8. 将双向关联改为单向关联
9. 以字面常量替换魔法数
10. 封装字段
11. 封装集合
12. 以数据类取代记录  记录是什么？
13. 以类取代类型码
14. 以子类取代类型码
15. 以state/strategy取代类型码
16. 以字段取代子类

==== 简化条件表达式 ====
1. 分解条件表达式
2. 合并条件表达式
3. 合并重复的条件代码块
4. 移除控制标记，用break或continue代替
5. 以卫句取代嵌套语句
6. 以多态取代条件表达式
7. 引入null对象 
8. 引入断言
	a. 帮助定位bug位置
	b. 帮助程序员理解代码

==== 简化函数调用 ====
1. 函数改名
	a. 先写个注释，然后缩减为名
2.添加参数 
3. 移除参数
4. 分解为查询函数和修改函数
5. 参数化合并函数
6. 以明确函数取代参数
7. 保留整个对象
	a. 缩短参数个数，传整个对象
8. 以函数取代参数
	a. 如果参数通过函数获得，那么可以在函数内调用那个函数来取代参数
9. 引入参数对象
	a. 与“保留整个对象”不同，这个重构的重点是，发现很多函数传递相同的多个参数，可能没有关系，但也可以抽取出一个对象
10. 移除设值函数
	a. 如果不想外界设置某个字段，就应该去掉设值函数
11. 隐藏函数
12. 以工厂函数取代构造函数
13. 封装向下转型
14. 以异常取代错误码
15. 以测试取代异常

==== 处理泛化关系（继承关系） ====
1. 字段上移
2. 函数上移
3. 构造函数上移
4. 函数下移
5. 字段下移
6. 抽取子类
7. 抽取超类
8. 抽取接口
9. 折叠继承关系
10. 构造模板函数
11. 以委托取代继承
12. 以继承取代委托

==== 大型重构 ====


