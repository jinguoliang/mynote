Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2016-10-18T15:16:55+08:00

====== 多态 ======
Created 星期二 18 十月 2016

1. 多态是面向对象语言的一个特性，前两个是抽象和继承，（还有一个是封装，为什么在最后？）
2. 多态提供了另一种分开接口和实现的方式，解耦 what 和 how。它增强了代码的组织性和可读性，同时创建了可扩展的程序，无论在项目的开始创建中，还是以后添加特性，程序都能以渐增的方式成长。
3. 封装通过结合各种特性和行为创建新类型。实现隐藏是通过将细节私有化，从而将接口从实现中分离。这种方式对于有过程化编程的人来说很容易接受。但是多态是关于类型分解的。从上一章我们知道，继承使得一个对象可以作为自己的类或者它的父类用。这种能力很重要，因为这样就可以将很多类型都当做一种类型来用。多态性允许继承自同一个类的不同类对于相同的接口有不同的实现。
4. 多态性又叫做动态绑定， 晚绑定，或者运行时绑定

=== 再来看看向上转型 ===
1. empty why resee
2. 忘记对象类型，抽象的统一处理

=== 深入理解 ===
1. 方法调用绑定 编译器如何知道传入的一个引用到底是什么类型？
	a. 一个方法调用和方法体之间的链接被称为调用绑定。
		1. 在运行之前绑定被称为早绑定（early binding） C 语言编译器就是这种
		2. 运行时绑定又叫晚绑定，动态绑定 要求在运行时确定对象的类型
	b. JAVA 中除了静态方法和 final 方法其他都是晚绑定
2. 产生正确的行为
	a. 传递正确的对象，执行正确的行为， 运行时决定
3. 可扩展性
	a. 很容易扩展，不需要修改之前的类，不需要重新编译之前的类
4. 陷阱： 覆盖私有方法
	a. 当覆盖私有方法时，在父类中调用该方法，即使对象是子类，但是依然调用的是父类方法，因为私有方法是不能重写的，那只是新写了一个方法而已
5. 陷阱：属性和静态方法
	a. 属性是不会多态的，因为它是在编译时解析的，所以当向上转型时，调用的是父类的属性
	b. 当子类覆盖父类的属性时，子类实际上拥有两个同名的属性，但是默认使用的都是子类的，父类的要使用 super 调用
	c. 静态方法同属性，也是在编译时确定的，没有多态性

=== 抽象类 ===
1. 抽象方法 abstract 修饰，没有方法体
2. 包含抽象方法的类叫抽象类，
3. 抽象类不能被实例化
4. 其子类要么实现其抽象方法，要么也要声明为抽象类
5. 不包含的如果声明为 abstract 也是可以的，也不能实例化

=== 接口 ===
1. interface 关键字声明一个接口，我们可以认为他是一个更纯的类，没有任何实现
2. 可以包含属性，但都是 static 和 final 的
3. 名如其意，它规定了一个接口或者叫协议
4. 实现接口的类要使用 implements 关键字代替 extends
5. 通过 extends 接口，可以定义新接口
6. java 里不支持多继承，但是有类似的方式，java 可以实现多个接口，先继承一个类，在实现多个接口
7. 父类中的方法如果与接口的方法一致，那么即使子类没有相应实现，也是可以向上转型为那个接口来使用的。

=== 内部类 ===
1. 一个类的定义在另一个类中或者方法中
2. 内部类 与 合成， 两者有着根本区别 
3. 内部类和向上转型  内部类可以被完全隐藏在一个类里，实现接口，从而对外界来看他们只知道接口，并不知道底层实现是那个类
4. 匿名内部类， 直接实现一个接口或者类，并赋给变量，不能有构建器
5. 内部类拥有一个封装对象的链接，它的存在依赖封装对象，这意味着可以访问封装对象的成员，并且没有访问限制
6. 静态内部类 
	a. 创建一个静态内部类不需要封装类的对象
	b. 不能访问封装类的对象
7. 引用外部累， 使用 OuterClass.this
8. 非静态内部类， 在外部实例化时要这样 outer.new Inner()
9. 继承内部类
{{./pasted_image003.tiff}}
10. 内部类标志符
	a. 每个类编译时都会生成.class文件，内部类也不例外，文件名为：封装类名$内部类名.class
	b. 但是匿名的呢？编译器会给匿名内部类简单的生成数字如：Outer$1.class

=== 构造器和多态 ===
1. 构造器的调用顺序
2. 继承和清理
3. 构造器中多态方法的行为
4. 协变的返回类型

=== 使用继承来设计 ===
6. 替换 vs 扩展
7. 向下类型转换 和 运行时类型信息

=== 总结 ===



